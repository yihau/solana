use {
    regex::Regex,
    std::{
        fs::File,
        io::{prelude::*, BufReader, BufWriter},
        path::PathBuf,
        str,
    },
};

/**
 * Extract a list of registered syscall names and save it in a file
 * for distribution with the SDK.  This file is read by cargo-build-sbf
 * to verify undefined symbols in a .so module that cargo-build-sbf has built.
 */
fn main() {
    let syscalls_rs_name = "../src/lib.rs";
    let syscalls_txt_name = "../../platform-tools-sdk/sbf/syscalls.txt";
    let build_sbf_syscalls_name = "../../platform-tools-sdk/cargo-build-sbf/src/syscalls.rs";
    println!("cargo::rerun-if-changed={syscalls_rs_name}");
    println!("cargo::rerun-if-changed={syscalls_txt_name}");
    println!("cargo::rerun-if-changed={build_sbf_syscalls_name}");
    println!("cargo::rerun-if-changed=build.rs");

    let syscalls_rs_path = PathBuf::from(syscalls_rs_name);
    let syscalls_txt_path = PathBuf::from(syscalls_txt_name);
    let build_sbf_syscalls_path = PathBuf::from(build_sbf_syscalls_name);
    println!(
        "cargo::warning=(not a warning) Generating {1} and {2} from {0}",
        syscalls_rs_path.display(),
        syscalls_txt_path.display(),
        build_sbf_syscalls_path.display(),
    );

    let old_num_syscalls = File::open(&build_sbf_syscalls_path)
        .map(|file| {
            let reader = BufReader::new(file);
            // The rust file contains two extra lines to make a proper rust array
            reader.lines().count().saturating_sub(2)
        })
        .unwrap_or(0);

    let mut file = match File::open(&syscalls_rs_path) {
        Ok(x) => x,
        Err(err) => panic!("Failed to open {}: {}", syscalls_rs_path.display(), err),
    };
    let mut text = vec![];
    file.read_to_end(&mut text).unwrap();
    let text = str::from_utf8(&text).unwrap();
    let sysc_re = Regex::new(r#"register_function\([[:space:]]*"([^"]+)","#).unwrap();
    let feature_gate_syscall_re =
        Regex::new(r#"register_feature_gated_function!\([^"]+"([^"]+)","#).unwrap();
    let new_num_syscalls = sysc_re
        .captures_iter(text)
        .chain(feature_gate_syscall_re.captures_iter(text))
        .count();
    if new_num_syscalls < old_num_syscalls {
        println!(
            "cargo:error=Number of syscalls reduced from {old_num_syscalls} to \
             {new_num_syscalls}, parsing logic in build.rs likely needs to be fixed."
        );
        std::process::exit(1);
    }

    let txt_file = match File::create(&syscalls_txt_path) {
        Ok(x) => x,
        Err(err) => panic!("Failed to create {}: {}", syscalls_txt_path.display(), err),
    };
    let mut txt_out = BufWriter::new(txt_file);
    let rs_file = match File::create(&build_sbf_syscalls_path) {
        Ok(x) => x,
        Err(err) => panic!("Failed to create {}: {}", syscalls_txt_path.display(), err),
    };
    let mut rs_out = BufWriter::new(rs_file);
    writeln!(rs_out, "pub(crate) const SYSCALLS: &[&str] = &[").unwrap();
    for caps in sysc_re
        .captures_iter(text)
        .chain(feature_gate_syscall_re.captures_iter(text))
    {
        let name = caps[1].to_string();
        writeln!(txt_out, "{name}").unwrap();
        writeln!(rs_out, "    \"{name}\",").unwrap();
    }
    writeln!(rs_out, "];").unwrap();
}
